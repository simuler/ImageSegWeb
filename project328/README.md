# day02

## 实现
1. 重新封装了Server类，使得该类能够直接用于创建服务端和客户端。构造函数的功能有创建socket，绑定ip和port；成员函数包括调用bind和listen、调用accept、调用connect、调用client_echo、调用server_echo

2. 实现了I/O复用功能，创建epoll监视发生事件的服务器socket，调用epoll_wait，当服务器socket发生事件时，调用accept，并将连接的客户端socket加入到epoll中，当客户端socket发生事件时，调用服务器的echo函数。

3. 将服务器socket设置为边缘触发。因为在水平触发方式中，如果服务器的输入缓冲区内有数据时，这个事件将一直被系统通知，造成了epoll多次通知一个事件，对性能造成浪费。因此设计为边缘触发方式，当有数据要读入时，该事件只通知一次，但这要求在这一次通知后，服务器能够一次把所有的数据加载完，因此将服务器设计为while调用read，保证数据被读取完。

4. 服务器socket和连接的客户端socket都被设计为非阻塞模式，因为边缘触发方式下，阻塞模式的read和write有可能引起服务器端的长时间停顿。由于事件只通知一次，一旦处理该事件，就需要处理输入缓冲区的所有数据，因此需要验证缓冲区是否为空。当read函数返回-1时，如果变量errno中的值为EAGAIN时，说明数据读完了，可以退出此次事件处理。


## 遇到的问题：
1. epoll_wait()函数一直返回-1，导致服务器无法接受客户端传输过来的数据。最后排查发现，epoll_create函数的输入参数不能为0,否则将创建文件描述符失败，但是linux版本大于2.6,这个参数应该是无用的。
2. 在实现服务器的echo时，阻塞在read函数，排查后发现，没有判断当read的返回值为-1时，应该判断error是否为EAGAIN，如果是，说明数据读取完毕，对数据进行回传，并退出。

## 使用方法
1. 运行 make，将生成server和client文件。
2. 分别运行./server 127.0.0.1 8888 和多个终端 ./client 127.0.0.1 8888。
3. 然后在多个client终端上输入字符，服务器将回传到client这些字符，在client终端输入q将退出该客户端。